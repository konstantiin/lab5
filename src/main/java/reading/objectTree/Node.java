package reading.objectTree;

import StoredClasses.annotations.AutoGenerated;
import StoredClasses.annotations.Boundaries;
import StoredClasses.annotations.NotNull;
import reading.generators.Generator;
import reading.readers.OnlineReader;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Node {
    public static List<Class<?>> leavesClasses = Arrays.asList(Boolean.class, Integer.class, Float.class, String.class, Double.class, Long.class, Short.class);
    private final String name;
    private final Class<?> type;
    private final List<Node> fields = new ArrayList<>();
    private Generator objectGenerator;
    private BigDecimal lowerBound = null;
    private BigDecimal upperBound = null;
    private boolean nullable = false;
    public Node(Class<?> type, String name) {
        this.type = type;
        this.name = name;
    }

    private static Generator getGenerator(Class<?> type) {
        String name;
        var temp = type.getName().split("[.]");
        name = "reading.generators." + temp[temp.length - 1] + "Generator";
        try {
            return (Generator) Class.forName(name).getConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException |
                 InvocationTargetException e) {
            System.err.println(name);
            throw new RuntimeException(e);
        }
    }

    public static Node generateTree(Class<?> type, String name) {
        Node root = new Node(type, name);
        root.setObjectGenerator(getGenerator(type));
        return create(root);
    }
    private static void setBounds(Node node, Field field){
        var b = field.getAnnotation(Boundaries.class);
        BigDecimal l = null, u = null;
        if (b != null) {
            l = new BigDecimal(b.lowerBound());
            u = new BigDecimal(b.upperBound());
        }
        if (l == null || b.lowerBound().equals("")) {
            if (field.getType() == Long.class || field.getType() == long.class)
                l = BigDecimal.valueOf(Long.MIN_VALUE);
            if (field.getType() == Float.class || field.getType() == float.class)
                l = BigDecimal.valueOf(Float.MIN_VALUE);
            if (field.getType() == Integer.class || field.getType() == int.class)
                l = BigDecimal.valueOf(Integer.MIN_VALUE);
            if (field.getType() == Short.class || field.getType() == short.class)
                l = BigDecimal.valueOf(Short.MIN_VALUE);
        }
        if (u == null || b.upperBound().equals("")) {
            if (field.getType() == Long.class || field.getType() == long.class)
                u = BigDecimal.valueOf(Long.MAX_VALUE);
            if (field.getType() == Float.class || field.getType() == float.class)
                u = BigDecimal.valueOf(Float.MAX_VALUE);
            if (field.getType() == Integer.class || field.getType() == int.class)
                u = BigDecimal.valueOf(Integer.MAX_VALUE);
            if (field.getType() == Short.class || field.getType() == short.class)
                u = BigDecimal.valueOf(Short.MAX_VALUE);
        }
        node.setLowerBound(l);
        node.setUpperBound(u);
    }
    private static Node create(Node root) {
        for (var field : root.getType().getDeclaredFields()) {
            if (field.isAnnotationPresent(AutoGenerated.class) || Modifier.isStatic(field.getModifiers())) continue;

            field.setAccessible(true);
            Node next = new Node(field.getType(), field.getName());

            next.setNullable(!field.isAnnotationPresent(NotNull.class) && !field.getType().isPrimitive());
            if (field.isAnnotationPresent(Boundaries.class) || OnlineReader.numbers.contains(field.getType())) {
                setBounds(next, field);
            }
            root.addField(next);
            if (field.getType().isEnum() || leavesClasses.contains(field.getType()) || field.getType().isPrimitive()) {
                continue;
            }

            next.setObjectGenerator(getGenerator(next.getType()));
            create(next);

        }
        return root;

    }

    public void setNullable(boolean nullable) {
        this.nullable = nullable;
    }

    public void addField(Node field) {
        fields.add(field);
    }

    public List<Node> getFields() {
        return fields;
    }

    public String getName() {
        return this.name;
    }

    public Class<?> getType() {
        return type;
    }

    public BigDecimal getLowerBound() {
        return this.lowerBound;
    }

    public void setLowerBound(BigDecimal lowerBound) {
        this.lowerBound = lowerBound;
    }

    public BigDecimal getUpperBound() {
        return this.upperBound;
    }

    public void setUpperBound(BigDecimal upperBound) {
        this.upperBound = upperBound;
    }

    public Generator getObjectGenerator() {
        return objectGenerator;
    }

    public void setObjectGenerator(Generator obj) {
        this.objectGenerator = obj;
    }

    public boolean ifNullable() {
        return nullable;
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(objectGenerator);
        res.append("\n");
        for (var x : fields) {
            res.append("\t").append(x.toString());
        }
        return res.toString();
    }

}
